#include "chassis_behaviour.h"
#include "detect_task.h"
#include "robot.h"
#include "gimbal_task.h"
#include "chassis_task.h"
#include "Remote_Control.h"
//debug
bool_t enterChassisDebugCondition()
{
	#ifdef DEBUG_CHASSIS
	return TRUE;
	#endif
	
	#ifndef DEBUG_CHASSIS
	return FALSE;
	#endif
}

bool_t outChassisDebugCondition()
{
	#ifdef DEBUG_CHASSIS
	return FALSE;
	#endif
	
	#ifndef DEBUG_CHASSIS
	return TRUE;
	#endif
}

void chassisDebugHandleFun(float *vx, float *vy, float *vz, float *none)
{	
	if(vx == NULL || vy == NULL || vz == NULL)
		return;
	if(toe_is_error(DBUSTOE))
	{
		*vx = 0;
		*vy = 0;
		*vz = 0;
		return;		
	}
	*vx = CHASSIS_NORMAL_MAX_VX*(RC_CH3_LUD_OFFSET/660.0);
	*vy = CHASSIS_NORMAL_MAX_VY*(RC_CH2_LLR_OFFSET/660.0);
	*vz = CHASSIS_NORMAL_MAX_VY*(RC_CH0_RLR_OFFSET/660.0);
	
	
	*vx = 0;
		*vy = 0;
		*vz = 0;
}

bool_t enterChassisClimbingCondition()
{
	
	return FALSE;
}

bool_t outChassisClimbingCondition()
{
	if(enterChassisClimbingCondition())
		return FALSE;
	return TRUE;
}

void chassisClimbingHandleFun(float *vx, float *vy, float *vz, float *none)
{	
	if(toe_is_error(DBUSTOE)||vx == NULL || vy == NULL || vz == NULL)
	{
		*vx = 0;
		*vy = 0;
		*vz = 0;
		return;		
	}
	//斜坡函数
	//loop_ramp_float(0, chassisTaskStructure.relativeAngleSet, 180.0/1000*CHASSIS_TASK_MS, chassisTaskStructure.minRelativeAngle, chassisTaskStructure.maxRelativeAngle);
	//PID_Calc(&(chassisTaskStructure.anglePidParameter), *(chassisTaskStructure.relativeAngle), chassisTaskStructure.relativeAngleSet);
	*vz = RC_CH2_LLR_OFFSET;//-chassisTaskStructure.anglePidParameter.output;
	//*vx = CHASSIS_NORMAL_MAX_VX*(RC_CH1_RUD_OFFSET/660.0);
	//*vy = CHASSIS_NORMAL_MAX_VY*(RC_CH0_RLR_OFFSET/660.0);
	//遥控器一阶滤波
	first_order_filter_cali(&chassisTaskStructure.chassis_cmd_slow_set_vx,CHASSIS_NORMAL_MAX_VX*(RC_CH1_RUD_OFFSET/660.0));
	first_order_filter_cali(&chassisTaskStructure.chassis_cmd_slow_set_vy,CHASSIS_NORMAL_MAX_VY*(RC_CH0_RLR_OFFSET/660.0));
	*vx=chassisTaskStructure.chassis_cmd_slow_set_vx.out;
	*vy=chassisTaskStructure.chassis_cmd_slow_set_vy.out;
	//float RAMP_float( float final, float now, float ramp);
//	RAMP_float(*vx,
	//loop_ramp_float(0, chassisTaskStructure.relativeAngleSet, 180.0/1000*CHASSIS_TASK_MS, chassisTaskStructure.minRelativeAngle, chassisTaskStructure.maxRelativeAngle);
}

//zeroForce
bool_t enterZeroForceCondition()
{
	if(toe_is_error(DBUSTOE) || toe_is_error(DETECT_CHASSIS_CM1_MOTOR) || toe_is_error(DETECT_CHASSIS_CM2_MOTOR) || toe_is_error(DETECT_CHASSIS_CM3_MOTOR) || toe_is_error(DETECT_CHASSIS_CM4_MOTOR))
	{ //电机离线
		return TRUE;
	}
	
	if(robotInf.modeStep < ROBOT_INIT_CHASSIS && robotInf.robotMode == ROBOT_INIT)
	{
		return TRUE;	
	}
	
	if(robotInf.robotMode == ROBOT_ZERO_FORCE)
		return TRUE;
	
	return FALSE;
}

bool_t outZeroForceCondition()
{
	if(enterZeroForceCondition())
		return FALSE;
	return TRUE;
}

void zeroForceHandleFun(float *raw_cm1, float *raw_cm2, float *raw_cm3, float *raw_cm4)
{
	*raw_cm1 = 0;
	*raw_cm2 = 0;
	*raw_cm3 = 0;
	*raw_cm4 = 0;
}

//CHASSIS_INIT
bool_t enterChassisInitCondition()
{
	if(robotInf.modeStep == ROBOT_INIT_CHASSIS && robotInf.robotMode == ROBOT_INIT)
		return TRUE;
	return FALSE;			
}

bool_t outChassisInitCondition()
{
	if(enterChassisInitCondition())
		return FALSE;
	return TRUE;
}

void chassisInitHandleFun(float *raw_cm1, float *raw_cm2, float *raw_cm3, float *raw_cm4)
{
	*raw_cm1 = 0;
	*raw_cm2 = 0;
	*raw_cm3 = 0;
	*raw_cm4 = 0;
	robotInf.modeStep = ROBOT_INIT_CHASSIS + 1;
}

//CHASSIS_SLEEP
bool_t enterChassisSleepCondition()
{
	if(gimbalTaskStructure.nowBehaviorName == SMALL_BUFF || gimbalTaskStructure.nowBehaviorName == BIG_BUFF)
	{
		return TRUE;
	}
	return FALSE;
}

bool_t outChassisSleepCondition()
{
	if(gimbalTaskStructure.nowBehaviorName == SMALL_BUFF || gimbalTaskStructure.nowBehaviorName == BIG_BUFF)
	{
		return FALSE;
	}
	return TRUE;	
}

void chassisSleepHandleFun(float* vx, float* vy, float* vz, float *none)
{
	if(vx == NULL || vy == NULL || vz == NULL)
		return;
	*vx = 0;
	*vy = 0;
	*vz = 0;
}

//CHASSIS_ROTATE
void chassisRotateHandleFun(float* vx, float *vy, float* vz, float* none)
{
	if(vx == NULL || vy == NULL || vz == NULL)
		return;
	
	*vz = CHASSIS_ROTATE_VZ;
	//陀螺模式下平移减速
	*vx = CHASSIS_NORMAL_MAX_VX/2*(RC_CH1_RUD_OFFSET/660.0);
	*vy = CHASSIS_NORMAL_MAX_VY/2*(RC_CH0_RLR_OFFSET/660.0);
}

bool_t enterChassisRotateCondition()
{
	if(IF_RC_SW1_UP && CHASSIS_FIRST_S2_UP)
		return TRUE;
	
	return FALSE;
}

bool_t outChassisRotateCondition()
{
	if(IF_RC_SW1_UP && !IF_RC_SW2_UP)
		return TRUE;
		
	return FALSE;
}

//独立不跟随模式
bool_t enterChassisAloneCondition()
{
	if(IF_RC_SW1_UP && CHASSIS_FIRST_S2_DOWN)
		return TRUE;
	return FALSE;
}
bool_t outChassisAloneCondition()
{
	if(IF_RC_SW1_UP && !IF_RC_SW2_DOWN)
		return TRUE;
	return FALSE;
}
void chassisAloneHandleFun(float* vx, float *vy, float* vz, float* none)
{
	*vx = CHASSIS_NORMAL_MAX_VX*(RC_CH1_RUD_OFFSET/660.0);
	*vy = CHASSIS_NORMAL_MAX_VY*(RC_CH0_RLR_OFFSET/660.0);
	*vz = 0;
}

//跟随模式
bool_t enterChassisFollowCondition()
{
	if(toe_is_error(YAW_MOTOR))
		return FALSE;
	if(gimbalTaskStructure.yawMotor.mode == GYRO)
		return TRUE;
	return FALSE;
}

bool_t outChassisFollowCondition()
{
	if(toe_is_error(YAW_MOTOR))
		return TRUE;
	if(gimbalTaskStructure.yawMotor.mode == GYRO)
		return FALSE;
	return TRUE;
}

void chassisFollowHandleFun(float *vx, float *vy, float *vz, float *none)
{
	if(vx == NULL || vy == NULL || vz == NULL)
		return;
	
	//斜坡函数
	loop_ramp_float(0, chassisTaskStructure.relativeAngleSet, 180.0/1000*CHASSIS_TASK_MS, chassisTaskStructure.minRelativeAngle, chassisTaskStructure.maxRelativeAngle);

	PID_Calc(&(chassisTaskStructure.anglePidParameter), *(chassisTaskStructure.relativeAngle), chassisTaskStructure.relativeAngleSet);
	*vz = -chassisTaskStructure.anglePidParameter.output;
	
	*vx = CHASSIS_NORMAL_MAX_VX*(RC_CH1_RUD_OFFSET/660.0);
	*vy = CHASSIS_NORMAL_MAX_VY*(RC_CH0_RLR_OFFSET/660.0);
}

